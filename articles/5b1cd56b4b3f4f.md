---
title: "Regoの基礎（文法編）"
emoji: "📑"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

この記事は[OPA/Regoアドベントカレンダー](https://adventar.org/calendars/6601)のN日目です。今回はOPAで利用されるポリシー記述言語であるRegoについて解説します。

詳しい文法については[公式ドキュメント](https://www.openpolicyagent.org/docs/latest/policy-language/)にまとまっているため、ここでは概要について述べたいと思います。

# 宣言的ポリシー記述言語：Rego

Regoは[Prolog](https://ja.wikipedia.org/wiki/Prolog)の一部の文法によって構成される[Datalog](https://en.wikipedia.org/wiki/Datalog)に着想を得て作られた言語です。構造化データを扱えるように拡張されつつ、構文もDatalogに比べるとかなり読みやすくなっています。

しかし近年メジャーに使われるプログラミング言語のほとんどは手続き型であり、宣言型の言語に馴染みがない人も多いかと思います。手続き型と比べると、以下のような点にギャップを感じるのではないかと思います。

- **記述の順序に意味がない**：手続き型の場合、命令文が実行された順序によって状態を維持しますが、Regoでは1つのルール内に記述された命令文（式）の順序に意味がありません。そのため、次の行で代入している変数を前の行で評価することもできます
- **変数に再代入できない**: 一度値を割り当てた変数は値を変えることができません
- **条件を満たす組み合わせを検証する、という書き方をする**: 例えば `data = {"a": 0, "b": 1, "c": 2}` という構造データから数値が `2` のものがあるかを検証する場合、「キーをiterationさせて値を比較する」という処理はせず、`data[_] == 2` という記述になります（ `_` がすべてのキーを意味する）

この他にも近代的なプログラミング言語からすると直感に反する記述方法（例えば[集合への要素の追加](https://play.openpolicyagent.org/p/vAiFKpdPPI)）があったりします。そのため、手続き型のプログラミング言語に慣れている人ほど、一度その経験を忘れて改めて覚えるというような姿勢が必要になりそうです。

# 具体例

[](https://zenn.dev/mizutani/articles/9b3993128f9f43)

```rego

```

# 入力と出力

```rego

```

# 代入のパターン

## if-then

## if-else-then

## Assignment と Unification

Regoにおけるいわゆる「代入」の機能は、"Assignment" (`:=`の記号を使う）と "Unification" （`=`の記号を使う）の2種類があります。