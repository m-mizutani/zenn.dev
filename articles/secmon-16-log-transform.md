---
title: "実践セキュリティ監視基盤構築(16): ログ変換"
emoji: "🔎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["security", "monitoring"]
published: false
---

この記事はアドベントカレンダー[実践セキュリティ監視基盤構築](https://adventar.org/calendars/9986)の16日目です。

今回はデータウェアハウスにおけるETL（Extract, Transform, Load）のうち、ログの変換（Transform）について紹介します。一般的なデータ基盤におけるTransformではデータクレンジングや集約などが主な処理ですが、セキュリティ監視基盤においては特にログのスキーマ変換が重要になります。

# ログの変換の必要性

セキュリティ監視基盤において利用するログデータはなんらかのシステムの内部で発生した、あるいはシステムが観測したイベントの記録になります。そのため、データ取得時におけるノイズなどは原則として発生せず[^data-noise]、そのままデータベースに取り込んでも問題ありません。

[^data-noise]: 例外として取得のための設定が間違っていたり、システムのバグによって不要なデータが発生するというケースはあります。

セキュリティ監視基盤でのTransformにおけるもっとも重要な処理は、ログのスキーマ変換です。ログデータは外部から提供されることが多く、そのスキーマは提供元の特性に合わせて決定されます。これに起因して主に2つの理由から、ログのスキーマ変換をできるようにするための仕組みを構築する必要があります。

## (1) 書込先のデータベースにあわせたスキーマに修正する

ログデータをデータウェアハウスに取り込む際には、書込先のデータベースにあわせたスキーマに修正する必要があります。近年利用できるデータウェアハウス向けのソフトウェア・サービスは様々な型に対応していますが、それでも全てのログをそのまま取り込めるわけではありません。いくつかの例を挙げると、以下のような修正が必要になることがあります。

### タイムスタンプ

時刻はログによって様々な形式で表現されます。Unix時間として数値で表現されることや、文字列で表現されることもあります。数値にしても秒、ミリ秒、ナノ秒のいずれで表現されるかはログによって異なりますし、文字列はさらに多様です。またタイムゾーンの情報が含まれているかどうかも異なります。これらをデータベースに取り込む際には、データベースの型に合わせて変換する必要があります。

また、ログを扱う際には「ログの発生時刻」と「ログの書込時刻」が全く異なるものである点にも注意が必要です。一部のデータベースではログの書込時間をそのまま利用することがありますが、これまでも述べたようにログがそのシステム上で発生した時刻と実際にログがデータベースに書き込まれるようになるまでは必ず遅延があります。なるべくリアルタイムにログを取り込む設計にしても数秒、遅延を許容するような設計なら数分になります。あるいは障害が発生してあとからログを取り込むなどの場合だと数時間から数日のズレが生じます。このような遅延を考慮して、ログの発生時刻を正しく取り込むための処理が必要になります。

### ネスト

現代のログデータは、その殆どがJSONのような構造化データで提供されます。これはログデータの構造的な意味を表現しているためなるべくならそのまま取り込むことが望ましいです。セキュリティ監視基盤に用いるようなデータベースは構造化データに対応しているものも多いですが、そうでない場合はフラットな構造に変換する必要があります。

フラット化する方法はいくつかありますが、なんらかの区切り文字を使ってフィールド名を連結する方法が一般的です。例えば以下のようになります。

変換前
```json
{
    "user": {
        "id": 123,
        "name": "Alice"
    },
    "action": "login"
}
```

変換後
```json
{
    "user.id": 123,
    "user.name": "Alice",
    "action": "login"
}
```

map形式の場合はこのような方法で問題ないのですが、ネスト構造の中に配列型が含まれる場合は注意が必要です。配列型はインデックスをフィールド名にする方法がありますが、構造をそのまま再現しているわけではありません。これは取り込み先のデータベースがこの差をうまく吸収してくれるかなどを確認しながら検討する必要があります。

### フィールド名

ログデータのフィールド名は提供元が決定します。例えばJSON形式で提供されるログデータの場合、フィールド名はUnicodeを含む任意の文字列が指定できます。しかし多くのデータベースではフィールド名に利用可能な文字の制限があります。また、フィールド名によっては予約語として利用できないものもあります。これらの制約に合わせてフィールド名を変更する必要があります。

## (2) 提供されるログの不安定なスキーマに対応する

先述している通り、外部システムから提供されるログは提供元によってスキーマが決定されますが、そのスキーマは不安定であることが多いです。これは筆者の体感ですが、外部サービスなどによる監査ログなどの提供は、ログの保全（利用者側へのバックアップ）と検索可能性のためであり、あくまで補助的なものという扱いが多いと考えています。そのためかログが提供されている場合でも、そのスキーマや仕様についてドキュメント化されたり、保証されていないケースは多々あります。

このようなケースではスキーマの不整合や変更が発生することがあり、これを「不安定」と表現しています。不安定なスキーマに対応するためには、ログの変換処理において柔軟な処理を行う必要があります。

具体的には、以下のようなケースが実際に起こります。

### 同じフィールド名で異なる型が混在する

```json
// log1
{
    "field1": 123
}

// log2
{
    "field1": "abc"
}
```

```json
// log1
{
    "field1": {
        "sub1": 123
    }
}

// log2
{
    "field1": [
        {
            "sub1": 123
        },
        {
            "sub1": 456
        }
    ]
}
```

### 同じフィールド名で異なるフォーマットが混在する

### スキーマが変更される



# ログ変換の実装とテスト

## ログ変換の実装方法

- どうしても一定ロジックを書く必要がある

## テスト可能性

- 正しく動くかの検証が必要
- こちらが立てばあちらが立たず
    - 回帰テストしないと死
