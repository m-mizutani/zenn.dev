---
title: "OPA/Regoの応用（脆弱性管理）"
emoji: "🔖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["opa", "rego", "trivy"]
published: false
---

この記事は[OPA/Regoアドベントカレンダー](https://adventar.org/calendars/6601)の23日目です。今回、次回ではOPA/Regoを使った応用事例について（構想段階のものも含めて）紹介したいと思います。本日は組織内で開発しているプロダクトの脆弱性管理についてになります。

今回のトピックは筆者が[Ubie Tech Talk 〜Ubieを支えるプロダクト基盤と分析環境〜](https://ubietechtalk.connpass.com/event/232243/)で講演させてもらった内容をベースに、発表時には時間の都合上割愛させてもらった技術の詳細について深堀りしたいと思います。発表資料やアーカイブは以下で閲覧できますので、興味のある方は併せてご覧ください。

https://www.youtube.com/watch?v=39ELMaNzPEg

https://speakerdeck.com/mizutani/trivy-rego

# 脆弱性の「管理」とは

すでに発表・資料内で説明しているのですが、簡単に整理だけしたいと思います。

昨今のソフトウェア開発（特にWebサービス周り）は3rd partyのパッケージを利用しないという選択肢はほぼなく、OSSを中心にその恩恵をうけながらの開発が主流です。外部パッケージの利用は開発のスピードを大幅に引き上げてくれる反面、そのパッケージに脆弱性が発見された場合にはリスクとなってしまいます。

脆弱性の検知のツールや脆弱性情報の流通は以前に比べて格段に改善されてきましたが、パッケージの更新などが遅滞なくできるかと言うとその限りではありません。アップグレードによる破壊的変更リスクの対応で更新できない、あるいはパッケージ側での対応が追いつかないなど様々な理由がありますが、「脆弱性のあるパッケージを更新できない・しない」という選択肢は現実に起こりえます。

では更新しないとなった場合、それは

- どのような理由か
- 誰が判断したのか
- いつまでそのようにしておくのか

という状態がわかるようにする必要があります。

また、上記をプロダクト開発チームが判断したとしても、セキュリティチームでは別の判断をするというケースもあります。脆弱性による影響は難しく、また対応するかどうかの判断は事業的な判断も絡むためチームによって過剰、あるいは過小にリスクを判断してしまう場合もありえます。しかし、深刻な影響が見込まれるような脆弱性の場合は確実に修正する必要があり、評価の指針や基準を整備する必要もあります。

このような **状態の把握** および **対応判断の評価** をまとめて、脆弱性の「管理」と呼んでいます。

# 管理のツール化

昔の脆弱性の管理はスプレッドシートのような「管理票」を用いて人間が検査・起票・更新・判断などをしてきました。しかし現代ではContinuous Integration (CI) の文化やツールが成長した結果、検査・起票・更新についてはソフトウェアで解決することができるようになりました。検査に関しては多様な静的解析ツールが出現し、起票や更新（つまり  **状態の把握** ）についても専用のサービス[^vuln-mgmt-tool]も充実してきました。

一方で **対応判断の評価** については現状だとまだあまり機能として充実したものはないと考えていました。独自のルールで評価をできるものはありますが、先述したとおり脆弱性は組織や環境、そのプロダクトが取り扱う情報によって影響範囲が変化するため、CVSSのような普遍的かつ共通の深刻度だけで対応を判断するのは困難です。

このような「状況に合わせて判断をする」というような仕組みはまさにOPA/Regoの得意とするところであり、この機能まで盛り込んだのが筆者が開発した[Octovy](https://github.com/m-mizutani/octovy)[^naming]になります。

https://github.com/m-mizutani/octovy


# 脆弱性やプロダクトに関するメタ情報の管理

OctovyはGitHub Appとして動作し、Appがインストールされたリポジトリ（あるいは組織）でコンテンツのpushがあった場合にWebhookでOctovyのサーバへ通知が送信され、その後[Trivy](https://https://github.com/aquasecurity/trivy)によってコードをスキャンします。スキャンした結果はDBに格納しつつ、OPAサーバに結果を問い合わせることでどのような対応をすればいいかという判定がOPAサーバから応答されます。

ここまでの話だと

# ルールの記述方法

```rego
default conclusion = "success"

fail_msg[msg] {
	vuln := input.sources[_].packages[_].vulnerabilities[_]
	vuln.custom_severity == "Critical"
	msg := sprintf("%s is critical vulnerability, have to be fixed", [vuln.id])
}

fail_msg[msg] {
	vuln := input.sources[_].packages[_].vulnerabilities[_]
	vuln.custom_severity == "High"
	input.repo.labels[_] == "public"
	msg := sprintf("%s severity is high and this product is exposed to internet.", [vuln.id])
}

conclusion = "failure" {
	count(fail_msg) > 0
}

messages = fail_msg {
	count(fail_msg) > 0
}
```

# セキュリティチームと開発チームのコミュニケーション

[^vuln-mgmt-tool]: 例えばSynkやYamoryといったツールが挙げられます
[^naming]: 言わずもがなですが、名前はOcto(cat) + (Tri)vyを拝借しました
